---
post_title: Manage Logon Hour via Windows PowerShell
username: farisnt@gmail.com
Catagories: PowerShell, Active Directory
Summary: How to change users Logon Hours using PowerShell
---


**Q:** How can I set AD domain user Logon Hour via Windows PowerShell ?

**A:** Most of the Active Directory object properties can be easily read or modified by using the `Get-` or `Set-` with the property name and its value, but when it comes to **LogonHours**, it not that easy. There are multiple steps and challenges required to build the value, and in this tutorial, you will learn all the tips and tricks needed to set the **LogonHours** hours via Windows PowerShell. So get a cup of coffee, and let's start.

## Logon Hours, Understanding the basics.

First, let's start with the GUI of the Logon Hours property by opening any AD user account property —> **Account** Tab —> click on **Logon Hours.** The default value is all blue, which represents logon permitted. If there is any white block, it represents a logon denied on that selected time/day slot.

In the example below, the user cannot log in on Sunday or Saturday all day but can log in from Monday through Friday. 

![Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled.png](Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled.png)

Logon Hours GUI

Make to enable the Advanced Features in Active Directory Management Console to see the Attribute Editor for the users, open the Active Directory console, click on **View** Menu and select **Advanced Features**. 

Start by selecting any user —> **Attribute Editor** tab. From the attributes, scroll to **LogonHours** and double click on it. Change the **Value Format** to **Binary.** 

![Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled%201.png](Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled%201.png)

Logon Hour in attribute

This is what represent the logon hours, but this is undoubtedly not a readable value and its not clear what these value means.

## Understanding LogonHour Property

In the **LogonHour**, each day of the week represented with 3 Byte (Three sets of **11111111** or **00000000**), and each 1 bit of the byte represent 1 hour

![Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled%202.png](Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled%202.png)

This user is allowed to login all the days though the week

- One Hour = 1 Bit
- Eight Hour = 1 Byte
- One Day (24 Hour) = 3 Byte (24 Bit)
- One Week = 21 Byte
- One week in Hours= 168 bit, which also mean One week have 168 Hour

All the result in the property are in a UTC standard.

Changing any value from 1 to 0 or 0 to 1 will be reflected in the Logon Hours GUI. Let's try to change the first bit in the first block, make it 0, and then see the result. 

So change the first block and make it **01111111**, click on OK to save, and open back the Logon Hour in the **Account** tab. See that there is only one block that is now marked as white.

![Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled%203.png](Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled%203.png)

Result After Changing 1 bit

In this post, what you see might "*till this point*" not look like what you see on your side, even after doing the same change, because the **LogonHour** property uses UTC standard time format.

I will explain more about this issue and how to fix it via the PowerShell script.

## Parameter for the PowerShell Script.

To make things easy to use for the user, I wrote a function **Set-LogonHours** that accepts the following parameter.

- **Identity:** The Username of the target principal (*String, Accept Pipeline, Position=0)*
- **TimeIn24Format:** Array of the hours access is permitted (*Array, ValidateRange (0- 23)*
- **Sunday:** Apply the TimeIn24Format to this day *(Switch)*
- **Monday:** Apply the TimeIn24Format to this day *(Switch)*
- **Tuesday:** Apply the TimeIn24Format to this day *(Switch)*
- **Wednesday:** Apply the TimeIn24Format to this day *(Switch)*
- **Thursday:** Apply the TimeIn24Format to this day *(Switch)*
- **Friday:** Apply the TimeIn24Format to this day *(Switch)*
- **Saturday:** Apply the TimeIn24Format to this day *(Switch)*
- **NonSelectedDaysAre:** This option for the weekdays that are not selected, what the default value should be, is it a permit or denied *(ValidateSet ="WorkingDays" or "NonWorkingDays").*

    ```powershell-console
    Set-LogonHours -identity "MyTestUser" -TimeIn24Format @(8,9,10,11,12)  -Monday -Tuesday -Wednesday -Thursday -NonSelectedDaysare WorkingDays
    ```

## Put it All in Action

First, create a Byte array, which will hold the final result as the **LogonHour** accepts a Byte array, not an integer array. The array length is 21, which represents a week. The number of Seven * (three blocks "which represent a day")  (7x3=21)

```powershell-console
$FullByte=New-Object "byte[]" 21
```

Then create a Hashtable that represents each hour of the day. The value of this hashtable will be set to **One** based on the user input

```powershell-console
$FullDay=[ordered]@{
        "1"=0
        "2"=0
        "3"=0
        "4"=0
        "5"=0
        "6"=0
        "7"=0
        "8"=0
        "9"=0
        "10"=0
        "11"=0
        "12"=0
        "13"=0
        "14"=0
        "15"=0
        "16"=0
        "17"=0
        "18"=0
        "19"=0
        "20"=0
        "21"=0
        "22"=0
        "23"=0
        "0"=0
        }
```

The hashtable value is base on what the user input in the array, so if the user type @(8,9,10,11,12,13,14,15), the respected value in the Hashtable should be set to 1, then join all the values together and store the result in a variable named `$Working`

```powershell-console
Foreach ($Singlevalue in $TimeIn24Format){
        $FullDay[$SingleValue]=1

        }
        $Working= -join ($FullDay.values)
```

Depend on the user input, and if the user chose to consider all the non-selected days to allow or denied to logon, the below code would set the default value for the non-selected days. Also, the Second **Switch** statement will fill the user added days parameter value with the allowed logon hours.

```powershell-console
Switch ($PSBoundParameters["NonSelectedDaysare"])
       
        {
            'NonWorkingDays' {$SundayValue=$MondayValue=$TuesdayValue=$WednesdayValue=$ThursdayValue=$FridayValue=$SaturdayValue="000000000000000000000000"} 
            'WorkingDays' {$SundayValue=$MondayValue=$TuesdayValue=$WednesdayValue=$ThursdayValue=$FridayValue=$SaturdayValue="111111111111111111111111"}
        }
Switch ($PSBoundParameters.Keys)
                {
                    'Sunday' {$SundayValue=$Working}
                    'Monday' {$MondayValue=$Working}
                    'Tuesday' {$TuesdayValue=$Working}
                    'Wednesday' {$WednesdayValue=$Working}
                    'Thursday' {$ThursdayValue=$Working}
                    'Friday' {$FridayValue=$Working}
                    'Saturday' {$SaturdayValue=$Working}
                    
                }
```

The next line will build up the full week string by combining all the values in one line, and this is needed to fix the TimeZone offset so that the script can give the same result regardless of the TimeZone. 

```powershell-console
$AllTheWeek="{0}{1}{2}{3}{4}{5}{6}" -f $SundayValue,$MondayValue,$TuesdayValue,$WednesdayValue,$ThursdayValue,$FridayValue,$SaturdayValue
```

## Timezone Challenge and Bits Shifting.

As mentioned before, the **LogonHours** value should be in the UTC standard time, and this led to the following possible scenarios:

- **Scenarios 1** **:** The user is located in a minus Timezone range like US, Canada with -8 Hours UTC
- **Scenarios 2**: The user is located in Zero Timezone range, such as Dublin, London +00 UTC
- **Scenarios 3**: The User is located in a plus Timezone such as Bangkok, Hanio, Jakarta +7 UTC

To see and understand the challenge, let's see it first in action to understand how to build the solution. Starting by setting the Timezone to any Timezone with 0 UTC, such as London, Dublin. **+0 UTC**. Then change the **Logon Hours** GUI for a test user to only be allowed to login 1 hour as the following, and this helps in seeing how this bit is moving by the change of the timezone

![Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled%204.png](Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled%204.png)

Only One bit is selected

Now change the Timezone to -2 or -3, such as (**UTC - 03:00) Salvador.** Open the same **Logon Hour** GUI interface again and see where the permitted login slot is now shifted.

![Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled%205.png](Manage%20Logon%20Hour%20via%20Windows%20PowerShell%20c28909d216f44708aad42cfa6706b403/Untitled%205.png)

The bit is shifted 3 bits to the left

The same thing happens if the selected timezone was **(UTC +)** the bit will shift to the right with the same hour's difference between UTC the selected Timezone. Timezone bias change should be reflected in the order of the bits, so the result is always correct.

In PowerShell, we can get the Timezone by using the `Get-Timezone` cmdlet. The `Get-Timezone` contains a property that shows the Timezone bias `(Get-TimeZone).baseutcoffset.hours`. Using this, it's possible to change the order of the bits based on the Timezone bais. 

```powershell-console
#Timezone in UTC -
If ((Get-TimeZone).baseutcoffset.hours -lt 0){
$TimeZoneOffset = $AllTheWeek.Substring(0,168+ ((Get-TimeZone).baseutcoffset.hours))
$TimeZoneOffset1 = $AllTheWeek.SubString(168 + ((Get-TimeZone).baseutcoffset.hours))
$FixedTimeZoneOffSet="$TimeZoneOffset1$TimeZoneOffset"
}
#Timezone is UTC +
If ((Get-TimeZone).baseutcoffset.hours -gt 0){
$TimeZoneOffset = $AllTheWeek.Substring(0,((Get-TimeZone).baseutcoffset.hours))
$TimeZoneOffset1 = $AllTheWeek.SubString(((Get-TimeZone).baseutcoffset.hours))
$FixedTimeZoneOffSet="$TimeZoneOffset1$TimeZoneOffset"
}
#Timezone is UTC 0
if ((Get-TimeZone).baseutcoffset.hours -eq 0){
$FixedTimeZoneOffSet=$AllTheWeek
}
```

## Building the Final Byte array and setting the values

Now the hours are aligned with the Timezone bias, and it's time to build the array and convert the string to a byte array. The result is now stored in a variable named `$FixedTimeZoneOffset`, and it should be split into a group of 8 characters be converted to Byte later.

Another challenge is each 8 bits group needs to have a reverse order, so the 1's and 0's order is reflecting the correct binary number bits order, and then update the result in the `$FullByte` variable, which will be used to update the AD user information by using ~~Set-ADUser~~ cmdlet

```powershell-console
$BinaryResult=$FixedTimeZoneOffSet -split '(\d{8})' | where {$_ -match '(\d{8})'}

                    Foreach($singleByte in $BinaryResult){
                        $Tempvar=$singleByte.tochararray()
                        [array]::Reverse($Tempvar)
                        $Tempvar= -join $Tempvar
                        $Byte = [Convert]::ToByte($Tempvar, 2)
                        $FullByte[$i]=$Byte
                        $i++

                        }

           Set-ADUser  -Identity $Identity -Replace @{logonhours = $FullByte}
```

```powershell-console
Function Set-LogonHours{
[CmdletBinding()]
Param(
[Parameter(Mandatory=$True)]
[ValidateRange(0,23)]
$TimeIn24Format,
[Parameter(Mandatory=$True,
          ValueFromPipeline=$True,
          ValueFromPipelineByPropertyName=$True, 
          Position=0)]$Identity,
[parameter(mandatory=$False)]
[ValidateSet("WorkingDays", "NonWorkingDays")]$NonSelectedDaysare="NonWorkingDays",
[parameter(mandatory=$false)][switch]$Sunday,
[parameter(mandatory=$false)][switch]$Monday,
[parameter(mandatory=$false)][switch]$Tuesday,
[parameter(mandatory=$false)][switch]$Wednesday,
[parameter(mandatory=$false)][switch]$Thursday,
[parameter(mandatory=$false)][switch]$Friday,
[parameter(mandatory=$false)][switch]$Saturday

)

Process{
$FullByte=New-Object "byte[]" 21

  $FullDay=[ordered]@{
        "1"=0
        "2"=0
        "3"=0
        "4"=0
        "5"=0
        "6"=0
        "7"=0
        "8"=0
        "9"=0
        "10"=0
        "11"=0
        "12"=0
        "13"=0
        "14"=0
        "15"=0
        "16"=0
        "17"=0
        "18"=0
        "19"=0
        "20"=0
        "21"=0
        "22"=0
        "23"=0
        "0"=0

        }

        Foreach ($singlevalue in $TimeIn24Format){
        $FullDay[$singlevalue]=1

        }
        $Working= -join ($FullDay.values)
        
        Switch ($PSBoundParameters["NonSelectedDaysare"])
       
        {
            'NonWorkingDays' {$SundayValue=$MondayValue=$TuesdayValue=$WednesdayValue=$ThursdayValue=$FridayValue=$SaturdayValue="000000000000000000000000"} 
            'WorkingDays' {$SundayValue=$MondayValue=$TuesdayValue=$WednesdayValue=$ThursdayValue=$FridayValue=$SaturdayValue="111111111111111111111111"}
        }

         Switch ($PSBoundParameters.Keys)
                {
                    'Sunday' {$SundayValue=$Working}
                    'Monday' {$MondayValue=$Working}
                    'Tuesday' {$TuesdayValue=$Working}
                    'Wednesday' {$WednesdayValue=$Working}
                    'Thursday' {$ThursdayValue=$Working}
                    'Friday' {$FridayValue=$Working}
                    'Saturday' {$SaturdayValue=$Working}
                    
                }
        $AllTheWeek="{0}{1}{2}{3}{4}{5}{6}" -f $SundayValue,$MondayValue,$TuesdayValue,$WednesdayValue,$ThursdayValue,$FridayValue,$SaturdayValue

#Timezone Check
                    if ((Get-TimeZone).baseutcoffset.hours -lt 0){
                    $TimeZoneOffset = $AllTheWeek.Substring(0,168+ ((Get-TimeZone).baseutcoffset.hours))
                    $TimeZoneOffset1 = $AllTheWeek.SubString(168 + ((Get-TimeZone).baseutcoffset.hours))
                    $FixedTimeZoneOffSet="$TimeZoneOffset1$TimeZoneOffset"
                    }

                    if ((Get-TimeZone).baseutcoffset.hours -gt 0){
                    $TimeZoneOffset = $AllTheWeek.Substring(0,((Get-TimeZone).baseutcoffset.hours))
                    $TimeZoneOffset1 = $AllTheWeek.SubString(((Get-TimeZone).baseutcoffset.hours))
                    $FixedTimeZoneOffSet="$TimeZoneOffset1$TimeZoneOffset"
                    }

                    if ((Get-TimeZone).baseutcoffset.hours -eq 0){
                    $FixedTimeZoneOffSet=$AllTheWeek
                    }

                    $i=0
                    $BinaryResult=$FixedTimeZoneOffSet -split '(\d{8})' | Where {$_ -match '(\d{8})'}

                    Foreach($singleByte in $BinaryResult){
                        $Tempvar=$singleByte.tochararray()
                        [array]::Reverse($Tempvar)
                        $Tempvar= -join $Tempvar
                        $Byte = [Convert]::ToByte($Tempvar, 2)
                        $FullByte[$i]=$Byte
                        $i++

                        }

           Set-ADUser  -Identity $Identity -Replace @{logonhours = $FullByte}             
                        
}
end{
Write-Output "All Done :)"
}

}

#Change the LogonHours for all the users in the Test OI
Get-ADUser -SearchBase "OU=Test,DC=test,DC=local" -Filter *| Set-LogonHours -TimeIn24Format @(8,9,10,11,12,13,14,15,16)  -Monday -Tuesday -Wednesday -Thursday -NonSelectedDaysare WorkingDays 
#Change the LogonHours for a single user
Set-LogonHours -Identity Jack.Ripper -TimeIn24Format @(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,0) -Monday -Tuesday -Wednesday -Thursday -Friday -NonSelectedDaysare NonWorkingDays #Allow Access during weekday
```
